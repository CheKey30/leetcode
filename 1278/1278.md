回文分割

给定字符串s和一个分割份数k，要求，将s分割为k个子字符串，并且把每个子字符串更改为回文字符串，求出最小的改动次数。

举例 s = abc，k=2，则 cost =1，可将abc 分为 ab和c，需要将b改为a，最小改动为1。

思路：

类似最优化问题肯定是dp来做，此题的妙处在于可以用两次dp，第一次用来求一个子字符串的改动次数，第二次用来求分割成k份总的cost。

dp一：

用二维数组cost来表示子串的改动次数，cost\[i][j] 表示 字符串从i到j需要改动的次数，则cost\[i][j] = (s\[i]!=\s[j])+cost\[i+1][j-1]。先将cost更新完毕，再dp二中使用。

dp二：

用二维数组dp来保存分割为k份的cost，dp\[i][k]表示从0到i的字符串分为k份需要的cost。则dp\[i][k]就是把字符串0到i分割为两部分，前半部分(0到j)分割为k-1份的cost加上后半部分(j+1到i)变为回文的cost中最小的。

初始情况为0到i作为1份的cost，即dp\[i][1]，由此继续递推下去。

最终的结果为dp\[s.len-1][k]